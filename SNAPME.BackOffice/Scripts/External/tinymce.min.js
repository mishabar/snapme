//angular.module("ui.tinymce",[]).value("uiTinymceConfig",{}).directive("uiTinymce",["$rootScope","$compile","$timeout","$window","$sce","uiTinymceConfig",function(a,b,c,d,e,f){f=f||{};var g=0,h="ui-tinymce";return f.baseUrl&&(tinymce.baseURL=f.baseUrl),{require:["ngModel","^?form"],priority:599,link:function(i,j,k,l){function m(a){a?(n(),p&&p.getBody().setAttribute("contenteditable",!1)):(n(),p&&!p.settings.readonly&&p.getBody().setAttribute("contenteditable",!0))}function n(){p||(p=tinymce.get(k.id))}if(d.tinymce){var o,p,q=l[0],r=l[1]||null,s={},t=function(b){var c=b.getContent({format:s.format}).trim();c=e.trustAsHtml(c),q.$setViewValue(c),a.$$phase||i.$digest()};k.$set("id",h+"-"+g++),o={},angular.extend(o,i.$eval(k.uiTinymce));var u=function(a){var b;return function(d){c.cancel(b),b=c(function(){return function(a){a.isDirty()&&(a.save(),t(a))}(d)},a)}}(400),v={setup:function(a){a.on("init",function(){q.$render(),q.$setPristine(),q.$setUntouched(),r&&r.$setPristine()}),a.on("ExecCommand change NodeChange ObjectResized",function(){u(a)}),a.on("blur",function(){j[0].blur(),q.$setTouched(),i.$digest()}),a.on("remove",function(){j.remove()}),o.setup&&o.setup(a,{updateView:t})},format:o.format||"html",selector:"#"+k.id};angular.extend(s,f,o,v),c(function(){s.baseURL&&(tinymce.baseURL=s.baseURL),tinymce.init(s),m(i.$eval(k.ngDisabled))}),q.$formatters.unshift(function(a){return a?e.trustAsHtml(a):""}),q.$parsers.unshift(function(a){return a?e.getTrustedHtml(a):""}),q.$render=function(){n();var a=q.$viewValue?e.getTrustedHtml(q.$viewValue):"";p&&p.getDoc()&&(p.setContent(a),p.fire("change"))},k.$observe("disabled",m),i.$on("$tinymce:refresh",function(a,c){var d=k.id;if(angular.isUndefined(c)||c===d){var e=j.parent(),f=j.clone();f.removeAttr("id"),f.removeAttr("style"),f.removeAttr("aria-hidden"),tinymce.execCommand("mceRemoveEditor",!1,d),e.append(b(f)(i))}}),i.$on("$destroy",function(){n(),p&&(p.remove(),p=null)})}}}}]);
/**
 * Binds a TinyMCE widget to <textarea> elements.
 */
angular.module('ui.tinymce', [])
  .value('uiTinymceConfig', {})
  .directive('uiTinymce', ['$rootScope', '$compile', '$timeout', '$window', '$sce', 'uiTinymceConfig', function ($rootScope, $compile, $timeout, $window, $sce, uiTinymceConfig) {
      uiTinymceConfig = uiTinymceConfig || {};
      var generatedIds = 0;
      var ID_ATTR = 'ui-tinymce';
      if (uiTinymceConfig.baseUrl) {
          tinymce.baseURL = uiTinymceConfig.baseUrl;
      }

      return {
          require: ['ngModel', '^?form'],
          priority: 599,
          link: function (scope, element, attrs, ctrls) {
              if (!$window.tinymce) {
                  return;
              }

              var ngModel = ctrls[0],
                form = ctrls[1] || null;

              var expression, options = {}, tinyInstance,
                updateView = function (editor) {
                    var content = editor.getContent({ format: options.format }).trim();
                    content = $sce.trustAsHtml(content);

                    ngModel.$setViewValue(content);
                    if (!$rootScope.$$phase) {
                        scope.$digest();
                    }
                };

              function toggleDisable(disabled) {
                  if (disabled) {
                      ensureInstance();

                      if (tinyInstance) {
                          tinyInstance.getBody().setAttribute('contenteditable', false);
                      }
                  } else {
                      ensureInstance();

                      if (tinyInstance && !tinyInstance.settings.readonly) {
                          tinyInstance.getBody().setAttribute('contenteditable', true);
                      }
                  }
              }

              // generate an ID
              attrs.$set('id', ID_ATTR + '-' + generatedIds++);

              expression = {};

              angular.extend(expression, scope.$eval(attrs.uiTinymce));

              //Debounce update and save action
              var debouncedUpdate = (function (debouncedUpdateDelay) {
                  var debouncedUpdateTimer;
                  return function (ed) {
                      $timeout.cancel(debouncedUpdateTimer);
                      debouncedUpdateTimer = $timeout(function () {
                          return (function (ed) {
                              if (ed.isDirty()) {
                                  ed.save();
                                  updateView(ed);
                              }
                          })(ed);
                      }, debouncedUpdateDelay);
                  };
              })(400);

              var setupOptions = {
                  // Update model when calling setContent
                  // (such as from the source editor popup)
                  setup: function (ed) {
                      ed.on('init', function () {
                          ngModel.$render();
                          ngModel.$setPristine();
                          ngModel.$setUntouched();
                          if (form) {
                              form.$setPristine();
                          }
                      });

                      // Update model when:
                      // - a button has been clicked [ExecCommand]
                      // - the editor content has been modified [change]
                      // - the node has changed [NodeChange]
                      // - an object has been resized (table, image) [ObjectResized]
                      ed.on('ExecCommand change NodeChange ObjectResized', function () {
                          debouncedUpdate(ed);
                      });

                      ed.on('blur', function () {
                          element[0].blur();
                          ngModel.$setTouched();
                          scope.$digest();
                      });

                      ed.on('remove', function () {
                          element.remove();
                      });

                      if (expression.setup) {
                          expression.setup(ed, {
                              updateView: updateView
                          });
                      }
                  },
                  format: expression.format || 'html',
                  selector: '#' + attrs.id
              };
              // extend options with initial uiTinymceConfig and
              // options from directive attribute value
              angular.extend(options, uiTinymceConfig, expression, setupOptions);
              // Wrapped in $timeout due to $tinymce:refresh implementation, requires
              // element to be present in DOM before instantiating editor when
              // re-rendering directive
              $timeout(function () {
                  if (options.baseURL) {
                      tinymce.baseURL = options.baseURL;
                  }
                  tinymce.init(options);
                  toggleDisable(scope.$eval(attrs.ngDisabled));
              });

              ngModel.$formatters.unshift(function (modelValue) {
                  return modelValue ? $sce.trustAsHtml(modelValue) : '';
              });

              ngModel.$parsers.unshift(function (viewValue) {
                  return viewValue ? $sce.getTrustedHtml(viewValue) : '';
              });

              ngModel.$render = function () {
                  ensureInstance();

                  var viewValue = ngModel.$viewValue ?
                    $sce.getTrustedHtml(ngModel.$viewValue) : '';

                  // instance.getDoc() check is a guard against null value
                  // when destruction & recreation of instances happen
                  if (tinyInstance &&
                    tinyInstance.getDoc()
                  ) {
                      tinyInstance.setContent(viewValue);
                      // Triggering change event due to TinyMCE not firing event &
                      // becoming out of sync for change callbacks
                      tinyInstance.fire('change');
                  }
              };

              attrs.$observe('disabled', toggleDisable);

              // This block is because of TinyMCE not playing well with removal and
              // recreation of instances, requiring instances to have different
              // selectors in order to render new instances properly
              scope.$on('$tinymce:refresh', function (e, id) {
                  var eid = attrs.id;
                  if (angular.isUndefined(id) || id === eid) {
                      var parentElement = element.parent();
                      var clonedElement = element.clone();
                      clonedElement.removeAttr('id');
                      clonedElement.removeAttr('style');
                      clonedElement.removeAttr('aria-hidden');
                      tinymce.execCommand('mceRemoveEditor', false, eid);
                      parentElement.append($compile(clonedElement)(scope));
                  }
              });

              scope.$on('$destroy', function () {
                  ensureInstance();

                  if (tinyInstance) {
                      tinyInstance.remove();
                      tinyInstance = null;
                  }
              });

              function ensureInstance() {
                  if (!tinyInstance) {
                      tinyInstance = tinymce.get(attrs.id);
                  }
              }
          }
      };
  }]);
